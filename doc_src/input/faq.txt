// (C) Copyright Renaud Detry       2007-2011.

namespace nuklei {

/**

@defgroup faq F.A.Q.

@section faq_thread_safe Is Nuklei thread-safe?

Short answer:

-# There is no access synchronization in Nuklei methods. An object should therefore never be read-modified simultaneously from multiple threads.

-# If Nuklei is compiled with
@verbatim
./scons.py use_openmp=no
@endverbatim
  then Nuklei objects can be created in multiple threads, as long as an object is not read-modified by multiple threads concurrently. However, <b>there will be no speed gain by using multiple threads</b>. Splitting a task in @f$ n @f$ chunks and running them in @f$ n @f$ threads will take almost the same wall time as running the @f$ n @f$ chunks successively in a single thread.

-# If Nuklei is compiled with the default config
@verbatim
./scons.py use_openmp=yes
@endverbatim
  then Nuklei objects can be created in multiple <b>OpenMP</b> threads, as long as they are not read-modified by multiple threads concurrently, and as long as <tt>omp_get_thread_num()</tt> returns a different value in concurrent threads, and that value belongs to @f$ [ 0, n [ @f$, where @f$ n @f$ is equal to the value that <tt>omp_get_max_threads()</tt> would return if it was called before main() (see below for more explanations). In this case, there will be a speed gain.

Longer answer:

Nuklei objects do not protect their members from concurrent access. As a result, one object can never be read-modified from multiple threads concurrently.

Nuklei does make use of global variables. These variables are random number generators, that are used in the methods of the Random class. In all Random methods but Random::uniformInt, the global generators are protected by a mutex. Random::uniformInt is crucial in the sence that it is called often during normal Nuklei operations. As a result, protecting it with a mutex slows down computations dramatically.

When Nuklei is compiled with <tt>openmp=no</tt>, Random::uniformInt is protected by a mutex, and multithreaded Nuklei executions are slow.

When Nuklei is compiled with the default <tt>openmp=yes</tt>, @f$ n @f$ generators are created before the execution of <tt>main()</tt>, where @f$ n @f$ is the return value of <tt>omp_get_max_threads()</tt>. Random::uniformInt then uses <tt>omp_get_thread_num()</tt> in order to use a different generator in each thread. This will only work if there is a single pool of threads active at any time, and the pool size is never increased. Note that in this case, the other Random methods are protected with <tt>omp critical</tt> instead of mutex, and are thus not safe with pthreads.

<a href="http://renaud-detry.net">Contact me</a> if you want to discuss this issue further. I've been working on multithreading Nuklei for a while and I might be able to help you.

@section faq_quaternion_norm What can I do if Nuklei quits and complains that FastNegExp is not correctly used?

For instance, what if I get the following error:
@code
libnuklei/base/nuklei/Math.h:72: T nuklei::FastNegExp(T) [with T = double]:
Assertion `0-1e-6 < fValue' failed
@endcode

Short answer: Try normalizing all the quaternions you give to Nuklei:

@code
double qw = ..., qx = ..., qy = ..., qz = ...; // Values produced by non-Nuklei code.
kernel::se3 k;
k.ori_.W() = qw;
k.ori_.X() = qx;
k.ori_.Y() = qy;
k.ori_.Z() = qz;
k.ori_ = la::normalized(k.ori_); // Make sure to have unit quaternions
@endcode

Long answer:

Nuklei expects that the data it receives is well-formed to an error of 1e-6. Providing Nuklei with a unit quaternion, or unit vector, whose norm is larger/smaller than 1 by more than 1e-6 will trigger exceptions at various places in the code.

When operating on quaternions, their value may drift away from normality. At places where it can afford it, Nuklei performs re-normalization of its data. Where it cannot, it checks that the data is ok. If not, it quits. Even though this behavior can appear quite strict, it often helps finding bugs. I have thus decided to leave it as is for the moment.

*/

}
