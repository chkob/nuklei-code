// (C) Copyright Renaud Detry       2007-2011.

/**

@ingroup using
@defgroup using_code Coding Details

*/


/**

@ingroup using_code
@defgroup programming_paradigm Programming Paradigms

Nuklei's code follows two distinct programming paradigms. Parts of 
Nuklei are written in generic C++, while other parts are written in object-oriented/polymorphic C++. Generic code (i.e., templates) is flexible and fast (static binding, allows for inlining). Unfortunately, generic code can quickly become obscure. Generic programming also restricts the range of programmers who will be comfortable with the code.

Parts of Nuklei where performance is an issue are written in generic code. This includes kernels and all their subroutines, which have to be inlinable. 
In parts of the code where performance is not an issue, Nuklei is written in an object-oriented/polymorphic style (i.e., virtual inheritance).

Kernels are at the meeting point of polymorphic and generic programming paradigms. Each kernel (nuklei::kernel::se3, nuklei::kernel::r3xs2p, nuklei::kernel::r3) has a statically bound interface, with copy semantics. The nuklei::kernel::base class is a polymorphic wrapper, with dynamically bound procedures. Several methods defined in nuklei::kernel::base start with @p poly, in order to avoid making virtual the methods of nuklei::kernel::se3, nuklei::kernel::r3xs2p, nuklei::kernel::r3 that must remain statically linkable:
@code
kernel::se3 k1, k2;
k1.polyEval(k2) // Slow evaluation - virtual table lookup necessary.
k1.eval(k2) // Fast evaluation - the method can be inlined.
kernel::base& k = k1;
k.polyEval(k2) // Again, slow evaluation.
k.eval(k2) // Compilation error - the base class only has the virtual methods.
@endcode
The template nuklei::kernel::implementation_prototype binds the polymorphic wrapper to static implementations. nuklei::kernel::implementation_prototype follows the CRTP trick to avoid clutter in derived kernels.

*/
